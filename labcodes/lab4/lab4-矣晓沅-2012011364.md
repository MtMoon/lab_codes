lab4 实验报告
=======================
计25 矣晓沅 2012011364
-----------------------------------------
# 练习一
*1.*  设计实现过程

练习一比较简单,按照要求在alloc_proc函数中对新申请的proc_struct进行相应的初始化即可.初始化的代码如下:

    proc->state = PROC_UNINIT;
    proc->pid = -1; //表示尚未完成创建
    proc->runs = 0;
    proc->kstack = 0;
    proc->need_resched = 0;
    proc->parent = NULL;
    proc->mm = NULL;
    proc->tf = NULL;
    proc->cr3 = boot_cr3; //内核线程,直接使用内核堆栈
    proc->flags = 0;
    memset(proc->name,0,sizeof(PROC_NAME_LEN + 1));
    memset(&(proc->context),0,sizeof(struct context));
     	
参考实验指导书,大部分的成员变量都设为0或NULL.其中有几个需要注意的地方,一是state设置为PROC_UNINIT,其对应于原理课上讲的"创建"状态,表示该线程正在创建,还在进行资源分配,数据结构初始化等工作.另外pid也设为-1,同样也是表示处于创建状态,尚未完成创建.实际的pid会在do_fork函数中通过get_pid函数获得.另外,cr3设置为boot_cr3.因为内核线程全部共用的是UCore的内核空间,所以直接把一级页表的基址设为UCore的页目录表基址即可.一般对用户进程来说,成员mm负责管理用户空间,其页目录表的基页也存于mm结构体中的pgdir里.这里因为是内核线程,所以不需要mm,因此就单独用一个cr3变量来保存页目录表基址.


*2.* 请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用

context是该线程的上下文内容,trapframe是该线程的中断帧.在proc.h中可以看到context的定义如下:

    struct context {
        uint32_t eip;
        uint32_t esp;
        uint32_t ebx;
        uint32_t ecx;
        uint32_t edx;
        uint32_t esi;
        uint32_t edi;
        uint32_t ebp;
    };
    
可以看到,"线程上下文"主要是保存了相关寄存器的值.context一般用于调度时的进程切换,当从进程A切换到进程B时,需要保存A的上下文,然后恢复B的上下文.只有恢复了B相关寄存器的值,才能保证B能够继续执行原来的程序.
    





# 练习二

*1.* 设计实现过程





*2.* 请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由


# 练习三

*1.* 在本实验的执行过程中，创建且运行了几个内核线程

*2.* 语句local_intr_save(intr_flag);....local_intr_restore(intr_flag)的作用

    
#其他

*1.* 我的实现与lab4_result中的实现区别

对练习一练习二，看了lab4_result中的实现，因为比较简单，实现都差不多。不多答案比较严重，很多代码执行后都加有assert判断。

*2.* 相关知识点

本次练习设计了虚拟内存管的相关知识，包括页缺失的中断服务例程的流程，页表项中相应标志位对页缺失调度的作用，以及FIFO和Clock等页置换算法。课上没有怎么涉及的是如何在Swap分区中定位一个缺失的页。此次实验中也只是简单的用了相应的函数，自己尚未对实际实现有深入的理解。



 


