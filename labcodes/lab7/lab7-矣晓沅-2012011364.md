lab7 实验报告
=======================
计25 矣晓沅 2012011364
-----------------------------------------
# 练习一

*1.* 内核级信号量的设计描述

在UCore中，信号量的实现主要涉及sem.c，sem.h和check_sync.c三个文件。信号量的结构体定义在sem.h中，定义如下：

    typedef struct {
        int value;
        wait_queue_t wait_queue;
    } semaphore_t;
    
包含一个信号量值value，等待在该信号量上的等待队列wait_queue。其中，等待队列的使用依赖于wait.h中定义的两个结构体，等待体wait_t和等待队列wait_queue_t。每次要将一个proc加入到等待队列时，通过调用相关函数，将一个proc包在一个wait_t中，再将这个wait_t挂到等待队列里。之所以要包一层，是因为wait_t结构体里的wakup_flag可以记录该进程的等待原因，同时分离队列的操作也更安全。

有了上述结构体之后，信号量的实现和使用依赖一对PV操作。这两个操作在lab7中为down和up。下面看down，up，init三个函数在sem.c中的具体实现。

    sem_init(semaphore_t *sem, int value) {
        sem->value = value;
        wait_queue_init(&(sem->wait_queue));
    }

信号量的初始化即设置value初值，初始化该信号量的等待队列。

对于P操作，即down函数，如下：

    static __noinline uint32_t __down(semaphore_t *sem, uint32_t wait_state) {
        bool intr_flag;
        local_intr_save(intr_flag);
        if (sem->value > 0) {
            sem->value --;
            local_intr_restore(intr_flag);
            return 0;
        }
        wait_t __wait, *wait = &__wait;
        wait_current_set(&(sem->wait_queue), wait, wait_state);
        local_intr_restore(intr_flag);
    
        schedule();
    
        local_intr_save(intr_flag);
        wait_current_del(&(sem->wait_queue), wait);
        local_intr_restore(intr_flag);
    
        if (wait->wakeup_flags != wait_state) {
            return wait->wakeup_flags;
        }
        return 0;
    }
    
该函数(以及up函数)中的实现与课上讲的略有区别，课上讲的是先将value减一然后再判断value是否小于0，这样value为负数时，其值就可以表示等待队列里正在等待的进程数。但此处的实现，时先判断是否大于0然后再减。value的操作应该是原子操作，此处通过开关中断来保证原子性。若value大于0，说明信号量还够，减一后返回；否则说明信号量不够，则将当前线程加入到该信号量的等待队列然后进程调度。当调度返回时，将其从等待队列中删除。

再看V操作，即up函数。

    static __noinline void __up(semaphore_t *sem, uint32_t wait_state) {
        bool intr_flag;
        local_intr_save(intr_flag);
        {
            wait_t *wait;
            if ((wait = wait_queue_first(&(sem->wait_queue))) == NULL) {
                sem->value ++;
            }
            else {
                assert(wait->proc->wait_state == wait_state);
                wakeup_wait(&(sem->wait_queue), wait, wait_state, 1);
            }
        }
        local_intr_restore(intr_flag);
    }
    
v操作利用关中断保证原子性，先取等待队列中的第一个进程，若为空，说明没有进程在等待该信号量，直接将value加一返回即可。否则，唤醒刚刚从等待队列中取出的进程。此时，刚刚进入等待的进程，即在down中调用schedule的进程会被唤醒，接着schedule()调用后执行，那么则会完成从等待队列中删除等操作。以上即为lab7中信号量的设计大大致执行流程。

*2.*用户态进程/线程提供信号量机制的设计方案

在lab7中，信号量用于解决哲学家就餐问题。该问题的代码在check_sync.c中实现。check_sync函数是在proc.c中的init_main中调用的，属于内核线程级函数。起始看其实现，我们可以发现，check_sync.c只是使用了信号量semaphore_t和down，up等函数，并没有直接设计内核级的操作。要在用户级实现信号量机制，一个可以考虑的方法是把信号量和up，down函数的实现全部移到用户级，即在user目录下定义相关的结构体和函数，然后通过用户态调用这些函数来实现信号量机制。对于up，down函数中涉及的内核操作，如schedule函数等，封装成系统调用共用户态进程进程调用。这个方法有一定的可行性，但是有很多问题。因为很多内核操作开放给用户态不安全，不利于隔离。同时对等待队列的操作中有很多细节实现起来较为麻烦，如将进程加入等待队列，实际上lab7的实现里，wait_current_set函数是直接将current proc加到了等待队列中，获取current这一操作也是内核级的。那么，如果要在用户态实现，是否还得将相关的操作都封装？这里感觉在用户态实现信号量机制没有太大必要，因为信号量本来就是用来解决多个进程对共享资源的互斥访问问题，而用户态进程没有必要关心多个进程的调度与协调，这是操作系统负责的。要在用户态实现的话，可以考虑由用户进程来负责对其创建的多个线程进行调度的控制，即将调度算法页放在用户态，OS只将wait sleep等系统调用函数提供给用户进程。再次假设下，就可以由用户进程来实现信号量机制，以控制多个子进程对资源的互斥访问，同时对等待队列的操作也会方便一些。


# 练习二

*1.*内核级条件变量的设计描述

*2.*用户态进程/线程条件变量的设计方案
