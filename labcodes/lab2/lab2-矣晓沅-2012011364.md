lab2 实验报告
=======================
计25 矣晓沅 2012011364
-----------------------------------------
# 练习一
*1.*  设计实现过程

整体的思路即标准的first-fit分配算法的思路。在初始化构建空闲块链表时，即按照地址从低到高进行构建。在pmm.c的page_init函数中，对init_memmap函数进行了调用，语句如下：

     init_memmap(pa2page(begin), (end - begin) / PGSIZE); 
     
在这之前，page_init函数已经完成了内存的探测，并把内存的信息存储在一个e820map结构体中。随后遍历可用的内存区域，调用init_memmap函数对该区域按页建立空闲块链表。在init_memmap中打印相关信息，可以看到：

    init memmap debug size: 32324 
    
实际上可用的内存分区只有一个，即init_memmap实际上只被调用了一次，然后建立了一个32324大的空闲分区。考虑到以后实验中可能有更多的内存可用，所以还是针对此做了相应处理。

查看了lab2_result中相应的实现，我的实现与其有一定的区别。lab2_result中，初始化，分配和回收都是按每一个页进行的，即lab2_result中的空闲块链表中添加了所有的page，并在alloc和free时，对所有的page进行相应的管理操作。我的实现是，在空闲块列表中只保存每个空闲块的第一个page。因为分配和使用时，实际上都是按块进行的，每个块的大小，PG_property  等标志位的信息，都是存在块的首个page中，因此空闲块链表中只需要保存每个块的首页，并且分配和释放时，只需要对首页进行相应的操作即可。如果按照lab2_result中的实现，每次分配和释放一个块是，都得对块中的所有page进行遍历增删。只保存首页时，一来可以节省增删的时间，二来在释放与合并时更方便。如果保存的是所有page，在空闲块列表中插入删除块时，就需要注意，要把该块的首page连接到前一个块的最后一个page上，而该块的后一个块需要与该块的最后一个page相连，此过程相应操作也会浪费一些时间。

具体实现上，init_memmap初始化时，依然对每一个page都初始化，但只是把首页base加入空闲块链表。而在alloc时，顺序遍历链表。因为原来各个page在地址上是由低到高连续的，所以按照first-fit的方法，空闲块链表中各个块的首page在地址上也是由低到高。alloc顺序遍历链表，找到大于等于n的块，从链表中删除该page。如果该块大于n，那么p+n就是该块被分割后剩下的碎片块的首page，此时只需要设置该page的相关参数并加入list即可。free的实现相对要稍微复杂一些。先进行相邻空闲块的合并，通过如下语句判断被释放的块是否有相邻的空闲块：

    base + base->property == p //base右边有空闲块
    p + p->property == base //base左边有空闲块
    
合并时，页只需修改相应首page的参数和增删相应首page即可。lab2_result中是统一采用list_add_before来添加，这样就比较简单。我实现是没有考虑到这一点，都采用了list_add(add after), 所以在合并完后，将base加入空闲块链表时，需要注意处理几种情况。一是此时链表为空，则直接加到头指针后；而是链表非空，则遍历链表，找到地址合适的位置进行添加。

*2.* 改进空间

按上述实现，应该比lab2_result要简单一些，但是因为没看lab3及之后的实验内容，还不清楚该实现在之后会不会产生什么问题。另外编程时感觉冗余较大，应该还有更简洁高效的改进方法。


# 练习二
*1.* 页目录项和页表中每个组成部分的含义和以及对ucore而言的潜在用处

页目录表项中包含页表的基址和一些标志位，页表项中包含页基址和一些标志位。标志位在mmu.h中有如下定义：

    #define PTE_P           0x001                   // Present
    #define PTE_W           0x002                   // Writeable
    #define PTE_U           0x004                   // User
    #define PTE_PWT         0x008                   // Write-Through
    #define PTE_PCD         0x010                   // Cache-Disable
    #define PTE_A           0x020                   // Accessed
    #define PTE_D           0x040                   // Dirty
    #define PTE_PS          0x080                   // Page Size
    #define PTE_MBZ         0x180                   // Bits must be zero
    #define PTE_AVAIL       0xE00                   // Available for software use
    // The PTE_AVAIL bits aren't used by the kernel or interpreted by the
    // hardware, so user processes are allowed to set them arbitrarily. 
    
关于这些标志位，还是又一些不太明白的地方，查了80386的页目录表项和页表项，似乎UCore与其有所区别。简单来啦看，各个标志位的含义及对UCore的潜在用处如下：

PTE_P:页表或者页是否存在的标志位。该位用于判断相应的页表或者页是否存在，在进行地址映射时，需要对该位进行检查。这一标志位在多级页表中有用，可以减小页表的大小。每个进程不一定都要映射全物理内存空间，对于没有用到的内存空间，可动态第在相应的页表或者页目录表上将PTE_P置0，则该表项更下一级的页表不需要再存储，则可减少页表对内存的占用。

PTE_W:页表是否可写的权限控制位，可以用于权限控制和保护，这样是页式存储管理实现共享与保护机制所需。

PTE_U:判断该页是否是用户态，是否能被用户操作。

PTE_PWT:写穿透标志。该标志位在启用Cache有用，若该位为1，则每次写操作时，需要同时写Cache和主存。

PTE_PCD:是否启用Cache的标志。

PTE_A:访问标志,表示该页是刚加入内存尚未被访问，还是已经被访问过了。

PTE_D:表示该页是否是Dirty的。此标志位在虚拟内存中有用。当发生缺页时，需要从硬盘中把一个页调入内存，若此时内存没有空闲的页，则需要根据相应的替换算法替换一个页出去。Dirty表示该页是否被写过，若被写过，则替换时需要将其内容更新到硬盘（交换分区）中；若未被写过，则直接丢弃即可。

PTE_PS: 页的大小，可以根据offset来加以检查，看页内访问是否越界。

*2.* 如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情

如果是与访问权限相关的异常，则操作系统会进入中断服务例程，进行报错等相关处理。如果是在使用了虚拟存储时，可能发生页缺失异常。此时是页表中的中对应的页并未在内存中。则此时，则需要取硬盘上的虚拟内存文件或交换分区中寻找相应的页加入到内存中，若内存无空闲页，则需要按照一定的替换算法替换出相应的页，如果该页被修改过，还需要将该页写回交换分区或虚拟内存文件中。然后还要重新执行之前的访存指令。


# 练习三
*1.* 数据结构Page的每一项与页表中的页目录项和页表项的对应关系
按照个人理解，page数组中的每一项都是一个page结构体，而每个page结构体中保存了内存里一个page的相关信息。在pmm.c中有如下代码：

    npage = maxpa / PGSIZE; 
    pages = (struct Page *)ROUNDUP((void *)end, PGSIZE); 
    for (i = 0; i < npage; i ++) {
        SetPageReserved(pages + i); 
    }
    uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage);

即从end开始的地址，按页大小边界取整后，作为存储pages数组的空间，而从freemem开始到KMEMSIZE的内存，为实际可用的空闲内存空间。这部分连续空间按页划分后，与pages数组中的Page结构体相对应。页大小为4K，如果是按照32为寻址空间，则32为虚地址中，第12为为页内偏移0ffset，中间10为为页表项index，高10位为页目录项index。每一个页目录项都对应一个页表，每个页表有1k个页，加上pte_index则对应到一个页表项。每一个页表项对应一个实际的页。在pmm.c的get_page函数中有如下代码：
 
    pte_t *ptep = get_pte(pgdir, la, 0);
    if (ptep_store != NULL) {
        *ptep_store = ptep;
    }
    if (ptep != NULL && *ptep & PTE_P) {
        return pa2page(*ptep);
    }
    
其中每个页表项可以直接对应到page数组中的一个Page结构体。在pmm.h中列出了pa2page的实现：

    static inline struct Page *
    pa2page(uintptr_t pa) {
    if (PPN(pa) >= npage) {
        panic("pa2page called with invalid pa");
    }
    return &pages[PPN(pa)];

即将该表项对应到相应的页号中，以页号作为Rank对应到page数组中的一项。    

*2.* 修改lab2使得虚拟地址与物理地址相等

lab2中，因为段机制采用的是对等映射，即虚地址等于线性地址，则要使得虚地址等于物理地址，只需要使得线性地址等于物理地址即可。在lab2中，由于X86物理地址从0开始，而GCC编译器编译出的虚拟地址从0xC0000000开始，所以满足如下关系：

    virt addr = linear addr = phy addr + 0xC0000000
    
在pmm.h中的KADDR宏与PADDR宏完成物理地址到虚拟地址的映射，其中通过相应地址加减KERNBASE即0xC0000000，只需在此对该值进行修改即可。


#其他

*1.* 我的实现与lab2_result中的实现区别

first-fit算法的实现与lab2_result中有区别，具体见上述练习1中的描述。练习2与练习3，我的实现与lab2_result没有根本性的区别

*2.* 相关知识点

练习一涉及到了第五讲连续内存分配，使用到了里面关于first-fit算法的相关知识。当然，附录中课上没有讲到的知识点如物理内存分布与大小探测也对理解相关代码和流程有一定作用。

练习二涉及到的是非连续内存分配中的页式存储管理/多级页表等知识，尤其是线性地址在各级页表间的转换关系。

联系三涉及到的也是页式存储管理的相关知识，以及TLB相关的一些概念。




 


