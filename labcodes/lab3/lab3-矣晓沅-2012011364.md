lab3 实验报告
=======================
计25 矣晓沅 2012011364
-----------------------------------------
# 练习一
*1.*  设计实现过程

Exercise1是缺页中断的服务例程程序do_pgfault。该函数传入参数和管理结构mm，错误代码error_code以及产生page fault的线性地址addr。在执行到Exercise1部分的代码前，需要先做一些检查等准备工作。包括在vma链表中查找addr属于哪个vma，如果不属于任何一个则报错。然后检查错误代码，因为产生page fault有三种情况：缺页，读写了无读写权限的页或者是用户态访问了内核态的页。根据错误类型的不同，进行相应的处理。通过对比错误代码和vma的权限属性来处理，vma的权限属性在vmm.h中定义如下:

    #define VM_READ 0x00000001 //只读
    #define VM_WRITE 0x00000002 //可读写
    #define VM_EXEC 0x00000004 //可执行
    
UCore的do_pgfault实际上只处理写一个存在的地址或写不存在的地址且地址可写或读不存在的地址且地址可读这三种情况，其他都直接保存。对这些缺页的情况，需要从硬盘上的swap文件中读取一个页到内存。UCore中利用了页表项的结构进行线性地址到Swap对应起始扇区的转换。当页不在内存中时，其页表项完成的是存储扇区编号的功能。所以通过get_pte函数获取页表项。页表项最低位是Preset位，当表项内容全为0时，即该页表尚未映射对应的物理空间，此时通过pgdir_alloc_page分配一页。通过pmm.c中pgdir_alloc_page的实现可看出，该函数完成了分配页，以page_insert函数建立地址映射/加入FIFO链表等工作。


*2.* 描述页目录表和页表组成部分对UCore实现页替换算法的潜在用处

页目录表项中包含页表的基址和一些标志位，页表项中包含页基址和一些标志位。标志位在mmu.h中有如下定义：

    #define PTE_P           0x001                   // Present
    #define PTE_W           0x002                   // Writeable
    #define PTE_U           0x004                   // User
    #define PTE_PWT         0x008                   // Write-Through
    #define PTE_PCD         0x010                   // Cache-Disable
    #define PTE_A           0x020                   // Accessed
    #define PTE_D           0x040                   // Dirty
    #define PTE_PS          0x080                   // Page Size
    #define PTE_MBZ         0x180                   // Bits must be zero
    #define PTE_AVAIL       0xE00                   // Available for software use

其中，如下标志位对页替换算法有潜在用处：

PTE_P:页表或者页是否存在的标志位。如果该位为0，说明对应的页不在内存中而是在Swap分区中，需要读取硬盘。

PTE_A:访问标志,表示该页是刚加入内存尚未被访问，还是已经被访问过了。该位可以用于Clock算法中，记录页是否被访问，从而按一定规则选该位为0的页进行替换。

PTE_D:表示该页是否是Dirty的。当发生缺页时，需要从硬盘中把一个页调入内存，若此时内存没有空闲的页，则需要根据相应的替换算法替换一个页出去。Dirty表示该页是否被写过，若被写过，则替换时需要将其内容更新到硬盘（交换分区）中；若未被写过，则直接丢弃即可。

*3.* 如果UCore缺页服务例程在执行过程中访存出现页访问异常，硬件要做哪些事情

如果是普通的缺页，则可以嵌套调用缺页服务例程。需要产生中断，根据中断号查找IDT，进入相应的中断服务例程。需要取硬盘上的虚拟内存文件或交换分区中寻找相应的页加入到内存中，若内存无空闲页，则需要按照一定的替换算法替换出相应的页，如果该页被修改过，还需要将该页写回交换分区或虚拟内存文件中。然后还要用iret返回，还要重新执行之前造成缺页的指令。但是缺页服务例程一般运行在内核态，内核态的缺页服务例程缺页，很可能导致系统挂了，一般内核态的程序都应该常驻内存。

# 练习二

*1.* 设计实现过程

这部分比较简单，实现_fifo_map_swappable函数中，只需要添加如下语句即可：

    list_add(head,entry);

该语句将一个新调入内存的页加到mm中的pra_page_link链表中，加到head之后。只要的话，表头之后是最新加入的页，表尾是最老的页。实际上，因为是双向链表，所以用list_add_after或者list_add_befor都可以，只要取的时候按照相应的顺序即可。

实现_fifo_swap_out_victim时，因为之前采用的list_add_after进行添加，则现在只要取head的前一个元素即时表尾最老的页。然后在链表中删除该页。调用_fifo_swap_out_victim函数，需要获取的是应该替换出去的页的Page结构体，该值是通过传如一个Page**类型的参数，通过对该参数赋值完成的。通过le2page获取list_entry_t对应的Page。这里需要注意，与lab2不同，le2page中第二个参数应该是pra_page_link而非page_link,这从le2page的实现可以看出。然后通过如下语句给参数赋值即可：

    *ptr_page = page;
    
比较捉急的是，英文的提示写的是 “set the addr of addr of this page to ptr_page”，所以我天真地直接写为了ptr_page = &page 然后运行时引发了第二次非法页缺失。查看swap.c中的swap_out函数，有如下代码：

    struct Page *page;
    int r = sm->swap_out_victim(mm, &page, in_tick);    
     v=page->pra_vaddr;  
     
可以看出，swap_out_victim函数需要将替换出去的page指针的内容赋值给传入参数地址里的指针。为了避免只是传值，从传参的时候传入了一个指针的地址，再通过向这个地址中的内容赋值的方式实现参数返回。


*2.* UCore中实现extended clock页替换算法的设计方案

详见下文“challenge——extended clock页替换算法”部分

# challenge——extended clock页替换算法

做了第一个扩展，在lab2的UCore实现了buddy分配算法，详细实现及测试代码在lab2->kern->mm中的buddy_pmm.c中，另外，为实现buddy system，对pmm.c和default_pmm.h也做了一定的修改。设计思路（可看做简要的设计文档）及测试说明如下：

*1.* 设计思路



#其他

*1.* 我的实现与lab3_result中的实现区别

first-fit算法的实现与lab2_result中有区别，具体见上述练习1中的描述。练习2与练习3，我的实现与lab2_result没有根本性的区别

*2.* 相关知识点

练习一涉及到了第五讲连续内存分配，使用到了里面关于first-fit算法的相关知识。当然，附录中课上没有讲到的知识点如物理内存分布与大小探测也对理解相关代码和流程有一定作用。

练习二涉及到的是非连续内存分配中的页式存储管理/多级页表等知识，尤其是线性地址在各级页表间的转换关系。

联系三涉及到的也是页式存储管理的相关知识，以及TLB相关的一些概念。




 


