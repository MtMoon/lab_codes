lab6 实验报告
=======================
计25 矣晓沅 2012011364
-----------------------------------------
# 练习一
*1.*  sched_class及Round Robin调度算法

在sched.h中，sched_class的定义如下：

    struct sched_class {
        const char *name;
        void (*init)(struct run_queue *rq);
        void (*enqueue)(struct run_queue *rq, struct proc_struct *proc);
        void (*dequeue)(struct run_queue *rq, struct proc_struct *proc);
        struct proc_struct *(*pick_next)(struct run_queue *rq);
        void (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);
    };
    
其中，name是调度算法的名字，init是初始化函数，enqueue将一个进程加入就绪队列，dequeue将一个进程从就绪队列中删除，pick_next从就绪队列中选择下一个要运行的进程，proc_tick是相应timetick的处理函数。这个结构体的各个成员都是函数指针，具体在default_sched.c中实现。并在sched.c的sched_init函数里，通过如下语句进行绑定。

    sched_class = &default_sched_class;
    
下面以lab6默认的Round Robin为例，描述UCore的执行过程以及sched_class中各个函数指针的调用。

在lab6中，各个函数的调用点如下：

do_exit(proc.c中) 当用户线程执行结束后，退出，cpu控制权交出

do_wait(proc.c中) 进程进入挂起状态，等待子进程结束退出

init_main(proc.c中)第一个实际的内核线程initproc，第一个用户进程是通过initproc创建的子进程加载的。initproc会等待所有用户子进程结束，然后调用schedule函数

cpu_idle(proc.c中)idle内核线程不断查询就绪队列，找到就绪进程并调用schedule函数进行调度。

trap(trap.c中)，用户态进程被打断，如果前进程控制块的成员变量need_resched设置为1，则当前线程会放弃CPU控制权

在各个调度点，最终都将掉欧诺个sched.c中的schedule函数进行调度，schedule函数定义如下：

    void
    schedule(void) {
        bool intr_flag;
        struct proc_struct *next;
        local_intr_save(intr_flag);
        {
            current->need_resched = 0;
            if (current->state == PROC_RUNNABLE) {
                sched_class_enqueue(current);
            }
            if ((next = sched_class_pick_next()) != NULL) {
                sched_class_dequeue(next);
            }
            if (next == NULL) {
                next = idleproc;
            }
            next->runs ++;
            if (next != current) {
                proc_run(next);
            }
        }
        local_intr_restore(intr_flag);
    }
    
可以看出，该函数的主体部分都用关中断来保证是原子操作。首先，将当前进程的need_resched设置为0，若当前进程是运行状态，则调用sched_class_enqueue将其加入就绪队列。在UCore中，就绪和运行都用PROC_RUNNABLE来表示，可以区别的是，当前进程若为PROC_RUNNABLE态，则是运行态，而就绪队列中的进程为就绪态。然后调用sched_class_pick_next选出下一个进程。若成功选出，则将其从就绪队列中删除。如果选取失败，则说明此时已无实际的进程需要运行，那么就将cpu使用权交回给idleproc。如果选取的进程与当前不相同，则调用proc_run进行进程切换。

具体来看Round Robin算法，该算法就是轮流使用时间片。RR_enqueue函数，就是简单地将进程proc加到就绪队列的队尾，重置时间片，RR_dequeue也是简单第进行删除。RR_pick_next则是直接选取队列头元素，用le2proc(le, run_link);转换为proc然后返回。


*2.*多级反馈队列调度算法概要设计    

多级反馈队列算法(MLFQ)大致有下列几个特点：

就绪队列被划分为多个子队列

每个子队列有不同的优先级

时间片大小随优先级别增加而增加

若进程在当前的时间片没有完成，则降到下一个优先级

根据上述特点，可以在sched.c中定义一个run_queue* 类型的数组，存储多个队列。并且可以实现不同的调度算法，在sched.c中定义sched_class *数组，用于绑定不同的调度函数。然后在run_queue结构体中，增加一个优先级变量uint32_t queue_priority,可以取消max_time_slice,再设置一个队列最小时间片min_time_slice,每次设置最大时间片时，设置为min_time_slice << queue_priority的大小。可以再在proc_struct结构体中，增加一个变量priority_of_queue，代表该进程目前所在的进程队列的优先级，根据这一变量的值，来判断该进程属于哪一个进程队列。对于当前正在运行的进程，它被调度时，会调用enqueue函数，可以将sche.c中的sched_class_enqueue等函数进行扩展，在一个函数里，根据进程所属队列的不同，来选择不同的调度算法。此时，“若进程在当前的时间片没有完成，则降到下一个优先级”这一特点可以在sched_class_enqueue函数中进行实现。在sched_class_enqueue对被调度的进程进行判断，如果进程的time_slice为0且不是僵尸状态(即尚未完成运行)，则将其从原本队列中删除并加入更高优先级的队列中。以上为大致的设计过程。


# 练习二

*1.* "Stride Scheduling调度算法的设计实现过程


